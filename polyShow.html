<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
	<head>
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
		</style>

		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 a_position;
			attribute vec2 a_texCoord;
			uniform vec2 u_resolution;
			varying vec2 v_texCoord;

			void main() {
				gl_Position = vec4(a_position, 1.0);
				v_texCoord = a_texCoord;
				gl_PointSize = 10.0;
			}
		</script>

		<script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;

			// our texture
			uniform sampler2D u_image;

			// the texCoords passed in from the vertex shader.
			varying vec2 v_texCoord;

			void main() {
			   gl_FragColor = texture2D(u_image, v_texCoord);
			}
		</script>


		<script type="text/javascript">
			var canvas, gl;
			var vertexShader, fragmentShader;
			var program, texCoordBuffer;
			var texCoordLocation, positionLocation;
			var texture;
			var texCoordBuffer, buffer;
			var image;
			var texCoord = [], vertices = [];

			function init() {
				// Get A WebGL context
				canvas = document.getElementById("test-canvas");
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;

				gl = canvas.getContext("experimental-webgl");
				if (!gl) {
					return;
				}

				image = new Image();
				image.src = "texture.png";  // MUST BE SAME DOMAIN!!!
				image.onload = function() {
					initShaders();
					initBuffers();
					initTexture();
					drawScene();
				}
			}

			function initShaders() {
				/* create vertex and fragment shaders */
				vertexShader = gl.createShader(gl.VERTEX_SHADER);
				fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

				/* bind shader to glsl */
				gl.shaderSource(vertexShader, document.getElementById("shader-vs").innerHTML);
				gl.shaderSource(fragmentShader, document.getElementById("shader-fs").innerHTML);

				/* compile and check vertex shader */
				gl.compileShader(vertexShader);
				if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
					alert("Cannot compile vertex shader!");
				}

				/* compile and check fragment shader */
				gl.compileShader(fragmentShader);
				if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
					alert("Cannot compile fragment shader!");
				}

				/* create GL program and link shaders */
				program = gl.createProgram();

				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);

				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					alert("Unable to initialize the shader program.");
				}

				//use program
				gl.useProgram(program);
			}

			function initBuffers() {
				// look up where the vertex data needs to go.
				positionLocation = gl.getAttribLocation(program, "a_position");
				texCoordLocation = gl.getAttribLocation(program, "a_texCoord");

				texCoordBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoord), gl.STATIC_DRAW);
				gl.enableVertexAttribArray(texCoordLocation);
				gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

				// Create a buffer for the position of the rectangle corners.
				buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

				gl.enableVertexAttribArray(positionLocation);
				gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
			}

			function initTexture() {
				// Create a texture.
				texture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, texture);

				// Set the parameters so we can render any size image.
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

				// Upload the image into the texture.
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

				// lookup uniforms
				var resolutionLocation = gl.getUniformLocation(program, "u_resolution");

				// set the resolution
				gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
			}

			function drawScene() {

				// Draw the rectangle.
				gl.drawArrays(gl.TRIANGLE_FAN, 0, vertices.length/3);
			}

			function fileUploadHandler(event) {
				var file = event.target.files[0];
				if (!file) {
					return;
				}
				vertices = [];
				texCoord = [];
				var reader = new FileReader();
				reader.onload = function(e) {
					var j=0;
					var content = e.target.result.split(",");
					for(var i=0; i<content.length; i++) {
						vertices.push(parseFloat(content[i]));
					}
					for(var i=0; i<vertices.length; i++) {
						if(j==2) {
							j=0;
							continue;
						}
						texCoord.push((vertices[i]+1)/2);
						j++;
					}
					console.log(vertices);
					console.log(texCoord);
					init();
				};
				reader.readAsText(file);
			}

			function signalHandlers() {
				document.getElementById('file-input').addEventListener('change', fileUploadHandler, false);
			}

		</script>
	</head>
	<body onload="signalHandlers()">
		<input type="file" id="file-input" />
		<canvas id="test-canvas"></canvas>
	</body>
</html>
